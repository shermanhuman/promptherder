# Superpowers Review — promptherder

**Reviewer:** Antigravity  
**Date:** 2026-02-07  
**Scope:** Full repository (`cmd/`, `internal/`, config files, README)

---

## Blockers

### B1. `.gitignore` ignores `.agent/` — the new source directory

**File:** `.gitignore:7`  
**Severity:** Blocker

```
# Generated by promptherder — source of truth is .antigravity/
.agent/
```

The `.gitignore` excludes `.agent/`, but `.agent/rules/` is now the source of truth that promptherder reads. If a user runs `promptherder` on itself (dogfooding), the `.agent/rules/` directory won't be committed. The comment is also stale — it references `.antigravity/` as the source of truth.

**Fix:** Remove the `.agent/` line or replace with a more targeted ignore. Update the comment.

---

### B2. Both `.antigravity/rules/` and `.agent/rules/` exist with stale, contradictory content

**Files:** `.antigravity/rules/00-promptherder.md`, `.agent/rules/00-promptherder.md`  
**Severity:** Blocker

The `.antigravity/rules/00-promptherder.md` still references the old architecture (generates `GEMINI.md`, reads from `.antigravity/rules/`). The `.agent/rules/00-promptherder.md` describes promptherder as "syncing Antigravity rules between `.antigravity/` and `.agent/`" — which is also wrong now. Neither file accurately describes the current behavior (reads `.agent/rules/`, generates Copilot outputs + manifest, no GEMINI.md).

**Fix:** Delete `.antigravity/rules/` entirely (or move content). Update `.agent/rules/00-promptherder.md` to accurately describe the current architecture.

---

## Majors

### M1. `readManifest` silently swallows corrupt JSON

**File:** `internal/app/sync.go:308-310`  
**Severity:** Major

```go
if err := json.Unmarshal(data, &m); err != nil {
    return manifest{}
}
```

If `manifest.json` exists but contains corrupt JSON (disk error, partial write, manual edit), promptherder treats it as "no previous manifest" and won't clean up any stale files. This could leave orphaned generated files forever. At minimum, log a warning so the user knows something is wrong.

**Fix:** Log the parse error at `WARN` level before returning the empty manifest.

---

### M2. `writeFile` does `MkdirAll` redundantly with `AtomicWriter`

**File:** `internal/app/sync.go:378-381`

```go
func writeFile(target string, content []byte) error {
    if err := os.MkdirAll(filepath.Dir(target), 0o755); err != nil {
        return fmt.Errorf("mkdir %s: %w", target, err)
    }
    writer := files.AtomicWriter{Path: target, Perm: 0o644}
```

`AtomicWriter.Write()` already calls `os.MkdirAll` (line 24 of `atomic.go`). The `writeFile` wrapper duplicates this. Not a bug, but the double `MkdirAll` is unnecessary work and confusing about where the responsibility lives.

**Fix:** Remove the `MkdirAll` from `writeFile` since `AtomicWriter` handles it, or remove it from `AtomicWriter` and make callers responsible. Pick one.

---

### M3. README claims "Gemini CLI reads `.agent/rules/` natively" — not accurate

**File:** `README.md:9,13`  
**Severity:** Major

Per the web research in this session, Gemini CLI uses `.gemini/` and `GEMINI.md`, not `.agent/`. The `.agent/` convention is specific to Antigravity. The README should be accurate about which tool reads what, or at least not claim Gemini CLI behavior that doesn't exist.

**Fix:** Say "Antigravity reads `.agent/rules/` natively" or more generically "Your AI coding agent reads `.agent/rules/` natively — promptherder generates the Copilot equivalents."

---

### M4. No test for end-to-end stale file cleanup via `Run`

**File:** `internal/app/sync_test.go`  
**Severity:** Major

There are good unit tests for `cleanStale` in isolation, and `TestRun_WritesManifest` verifies the manifest gets created. But no test runs `Run` twice — once to generate files, then again after removing a source — to verify the full idempotent cleanup loop works end-to-end.

**Fix:** Add a test that: (1) runs `Run` with source A and B, (2) deletes source B, (3) runs `Run` again, (4) asserts B's output file is deleted and A's remains.

---

### M5. `Run` doesn't delete the manifest itself when `sources == 0`

**File:** `internal/app/sync.go:83-86`  
**Severity:** Major

When no source files are found, `Run` returns early without writing a manifest or running cleanup. If a previous run generated files and wrote a manifest, then all source rules are deleted, promptherder won't clean up the stale outputs — it just says "no source files found" and exits.

**Fix:** When `sources == 0`, still load the old manifest and run cleanup to remove any previously generated files. Write an empty manifest afterward.

---

## Minors

### m1. `sourceDir` hardcoded — not configurable

**File:** `internal/app/sync.go:25`  
**Severity:** Minor

The source directory is a compile-time constant. The `Config` struct doesn't expose it. This means if someone uses a different convention (e.g. `.gemini/rules/`, `.rules/`), they can't use promptherder without forking.

**Fix:** Add a `SourceDir` field to `Config` with a default of `.agent/rules`.

---

### m2. `parseFrontmatter` only recognizes `applyTo` — fragile key parsing

**File:** `internal/app/sync.go:263-271`  
**Severity:** Minor

The frontmatter parser uses string prefix matching (`strings.HasPrefix(line, "applyTo:")`) instead of proper YAML parsing. This means `applyTo` with extra whitespace before the key (e.g. `  applyTo: "**/*.sh"`) won't be matched. The `TrimSpace` at line 264 handles trailing whitespace before the key but doesn't help with leading whitespace in the raw line — wait, it actually does since `line = strings.TrimSpace(line)` happens first. So this is fine for whitespace, but would still break on `applyto:` (case sensitivity) or `apply_to:`.

Not a real bug currently, but worth noting the parser is minimal.

---

### m3. `AtomicWriter` doesn't sync/fsync before rename

**File:** `internal/files/atomic.go:46-52`  
**Severity:** Minor

The atomic write pattern is: write → chmod → close → rename. Best practice for crash safety is to `fsync` before close to ensure data hits disk before the rename makes it visible. Without `fsync`, a crash between close and rename could leave a zero-length or partial file at the final path on some filesystems.

For a CLI tool that generates markdown config files, this is extremely low risk. But it's a well-known gap in atomic write patterns.

---

### m4. `dry-run` still reads the old manifest and computes cleanup, but doesn't show the new manifest path

**File:** `internal/app/sync.go:110-116`  
**Severity:** Minor

In dry-run mode, promptherder doesn't write the manifest (correct), and it does show "dry-run: would remove stale" for cleanup (good). But it doesn't show "would write manifest to .promptherder/manifest.json", so the user doesn't see the full picture of what will change.

**Fix:** Add a dry-run log line for the manifest write.

---

### m5. No `.promptherder/` entry in `.gitignore` guidance

**File:** `README.md`  
**Severity:** Minor

The README doesn't mention whether `.promptherder/manifest.json` should be committed to git. Since the manifest is needed for cross-machine stale cleanup, it should be committed. But users won't know this unless told.

**Fix:** Add a note to the README: "Commit `.promptherder/manifest.json` to your repo so cleanup state persists across machines."

---

## Nits

### N1. Comment on `Run` says "Gemini CLI reads .agent/rules/ natively"

**File:** `internal/app/sync.go:64`

Same inaccuracy as M3 in code comments. Should say "Antigravity" or be more generic.

---

### N2. `new` as a parameter name shadows the builtin

**File:** `internal/app/sync.go:346`

```go
func cleanStale(repoPath string, old, new manifest, ...) error {
```

`new` is a Go builtin. Using it as a parameter name is valid Go but can confuse readers and linters. Consider `newManifest` or `cur`.

---

### N3. `LICENSE` is MIT but no copyright holder listed in source files

**File:** `LICENSE`

Standard practice for Go projects is to have the copyright in `LICENSE` only, so this is fine. Just noting for completeness.

---

### N4. Binary `promptherder.exe` committed to git

**File:** `promptherder.exe`

The `.gitignore` has `/promptherder.exe` which should prevent this, but the binary is present in the working tree. Verify it's actually gitignored and not tracked.

---

## Summary

**Overall:** Clean, well-structured small Go CLI. The code is readable, the test coverage is solid (28 tests covering unit and integration paths), and the architecture is sound. The manifest-based cleanup is a significant improvement over marker-based detection.

### Critical fixes needed:

1. **B1:** Fix `.gitignore` — it excludes `.agent/`, the new source directory
2. **B2:** Clean up `.antigravity/rules/` and update `.agent/rules/` to match current behavior
3. **M5:** Handle the `sources == 0` case for cleanup (currently bypasses it entirely)

### Recommended next actions:

1. Fix the two Blockers and M5 (the zero-sources cleanup gap)
2. Add the end-to-end idempotency test (M4)
3. Fix the README inaccuracy about Gemini CLI (M3)
4. Log a warning on corrupt manifest (M1)
5. Remove the duplicate `MkdirAll` (M2)
